/*
 * This file is part of the Head Tracker distribution (https://github.com/dlktdr/headtracker)
 * Copyright (c) 2021 Cliff Blackburn
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "btparahead.h"

#include <bluetooth/bluetooth.h>
#include <bluetooth/conn.h>
#include <bluetooth/gatt.h>
#include <bluetooth/hci.h>
#include <bluetooth/uuid.h>
#include <zephyr.h>

#include "defines.h"
#include "io.h"
#include "log.h"
#include "nano33ble.h"
#include "targets/nrf52/blechars.h"
#include "trackersettings.h"

void sendTrainer();
int setTrainer(uint8_t *addr);
void pushByte(uint8_t byte);

static void disconnected(struct bt_conn *conn, uint8_t reason);
static void connected(struct bt_conn *conn, uint8_t err);
ssize_t write_friendly(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
                        uint16_t len, uint16_t offset, uint8_t flags);
static ssize_t write_friendlys(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
                        uint16_t len, uint16_t offset, uint8_t flags);
static ssize_t write_delete(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
                        uint16_t len, uint16_t offset, uint8_t flags);
static ssize_t write_myself(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf,
                        uint16_t len, uint16_t offset, uint8_t flags);


static constexpr uint8_t START_STOP = 0x7E;
static constexpr uint8_t BYTE_STUFF = 0x7D;
static constexpr uint8_t STUFF_MASK = 0x20;
static uint8_t buffer[BLUETOOTH_LINE_LENGTH + 1];
static uint16_t chan_vals[TrackerSettings::BT_CHANNELS];
static uint8_t bufferIndex;
static uint8_t crc;
static uint8_t ct[40];
static char _address[18] = "00:00:00:00:00:00";
uint16_t ovridech = 0xFFFF;

// JSON Ring Buffer Reader
DynamicJsonDocument blejson(JSON_BUF_SIZE);
char blejsonbuffer[JSON_BUF_SIZE] = "";
char *blejsonbufptr = blejsonbuffer;

// Service UUID
struct bt_uuid_16 bt_char_fiendly  = BT_UUID_INIT_16(0xF399);
struct bt_uuid_16 bt_char_fiendlys = BT_UUID_INIT_16(0xF398);
struct bt_uuid_16 bt_char_delete   = BT_UUID_INIT_16(0xF391);
struct bt_uuid_16 bt_char_myself   = BT_UUID_INIT_16(0xF390);

BT_GATT_SERVICE_DEFINE(
    bt_srv,
    // ATTRIBUTE 0
    BT_GATT_PRIMARY_SERVICE(BT_UUID_DECLARE_16(0xF003)),

    // Data output Characteristic  ATTRIBUTE 1
    BT_GATT_CHARACTERISTIC(&bt_char_fiendly.uuid, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_friendly, ct),
    BT_GATT_CHARACTERISTIC(&bt_char_fiendlys.uuid, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_friendlys, ct),
    BT_GATT_CHARACTERISTIC(&bt_char_delete.uuid, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_delete, ct),
    BT_GATT_CHARACTERISTIC(&bt_char_myself.uuid, BT_GATT_CHRC_WRITE, BT_GATT_PERM_WRITE, NULL, write_myself, ct),

    // AUTOGENERATED_CHARACTERISTICS // Automatically generated in blechars.h
);

static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA_BYTES(BT_DATA_UUID16_SOME, BT_UUID_16_ENCODE(0xF003)),
#if defined(BT_MOD_CC2540)
    BT_DATA_BYTES(0x12, 0x00, 0x60, 0x00, 0x60),
#endif
};

static struct bt_le_adv_param my_param = {
    .id = BT_ID_DEFAULT,
    .sid = 0,
    .secondary_max_skip = 0,
    .options = (BT_LE_ADV_OPT_CONNECTABLE | BT_LE_ADV_OPT_USE_NAME | BT_LE_ADV_OPT_USE_IDENTITY |
                BT_LE_ADV_OPT_CODED),
    .interval_min = (BT_GAP_ADV_FAST_INT_MIN_2),
    .interval_max = (BT_GAP_ADV_FAST_INT_MAX_2),
    .peer = (NULL),
};

struct bt_conn *curconn = NULL;
struct bt_le_conn_param *conparms =
    BT_LE_CONN_PARAM(BT_MIN_CONN_INTER_PERIF, BT_MAX_CONN_INTER_PERIF, 0, BT_CONN_LOST_TIME);

static struct bt_conn_cb conn_callbacks = {
    .connected = connected,
    .disconnected = disconnected,
    .le_param_req = leparamrequested,
    .le_param_updated = leparamupdated,
    .le_phy_updated = lephyupdated,
    //.security_changed = securitychanged
};

static struct bt_conn_le_phy_param phy_params = {
    .options = BT_CONN_LE_PHY_OPT_CODED_S8,
    .pref_tx_phy = BT_GAP_LE_PHY_CODED,
    .pref_rx_phy = BT_GAP_LE_PHY_CODED,
};

bt_addr_le_t addrarry[CONFIG_BT_ID_MAX];
size_t addrcnt = 1;

void BTHeadStart()
{
  bleconnected = false;

  // Center all Channels
  for (int i = 0; i < TrackerSettings::BT_CHANNELS; i++) {
    chan_vals[i] = TrackerSettings::PPM_CENTER;
  }

  LOGI("BLE Starting Head Bluetooth");

  // Start Advertising
  int err = bt_le_adv_start(&my_param, ad, ARRAY_SIZE(ad), NULL, 0);
  if (err) {
    LOGE("Advertising failed to start (err %d)", err);
    return;
  }

  LOGI("BLE Started Advertising");

  bt_conn_cb_register(&conn_callbacks);

  // Discover BT Address
  bt_id_get(addrarry, &addrcnt);
  if (addrcnt > 0) bt_addr_le_to_str(&addrarry[0], _address, sizeof(_address));

  crc = 0;
  bufferIndex = 0;
}

void BTHeadStop()
{
  LOGI("BLE Stopping Head Bluetooth");

  // Stop Advertising
  int rv = bt_le_adv_stop();
  if (rv) {
    LOGE("BLE Unable to Stop advertising");
  } else {
    LOGI("BLE Stopped Advertising");
  }

  if (curconn) {
    LOGI("BLE Disconnecting Active Connection");
    bt_conn_disconnect(curconn, 0);
    bt_conn_unref(curconn);
  }
  curconn = NULL;

  bleconnected = false;
}

void BTHeadExecute()
{
  if (bleconnected) {
    clearLEDFlag(LED_BTSCANNING);
    setLEDFlag(LED_BTCONNECTED);
    // Send Trainer Data
    uint8_t output[BLUETOOTH_LINE_LENGTH + 1];
    int len;
    len = setTrainer(output);

    // bt_gatt_notify(NULL, &bt_srv.attrs[1], output, len);
  } else {
    // Scanning
    setLEDFlag(LED_BTSCANNING);
    clearLEDFlag(LED_BTCONNECTED);
  }
}

const char *BTHeadGetAddress() { return _address; }

bool BTHeadGetConnected() { return (bleconnected); }

void BTHeadSetChannel(int channel, const uint16_t value)
{

}

// Head BT does not return BT data
uint16_t BTHeadGetChannel(int channel) { return 0; }

int8_t BTHeadGetRSSI()
{
  // *** Implement
  return -1;
}

typedef struct __attribute__((__packed__))  {
    char name[4];
    uint32_t tilt;
    uint32_t pan;
    uint32_t distance;
} mydata_s;

typedef struct __attribute__((__packed__))  {
    char name[16];
    int32_t lat;
    int32_t lon;
    int32_t alt;
} navi_data_s;

#include "AR/common_ar.h"

typedef struct __attribute__((__packed__))  {
    char name[16];
    int32_t lat;
    int32_t lon;
    int32_t alt;
    enum Point_Type_T point_type;
} navi_data_v2_s;

struct PACKAGED {
  uint8_t version;
  uint8_t size;
  navi_data_v3_s frame[5];
};

#include "AR/position.h"
#include "AR/navigation.h"
#include "AR/common_ar.h"

static void printf_raw_data(navi_data_v3_raw_s raw_data)
{
  debug("name= %s\r\n"
        "lat = %d\r\n"
        "lon = %d\r\n"
        "alt = %d\r\n"
        "id  = %d\r\n"
        "ttl = %d\r\n"
        "typ = %d",
        raw_data.name,
        raw_data.lat,
        raw_data.lon,
        raw_data.alt,
        raw_data.nav.id,
        raw_data.ttl,
        raw_data.point_type);
}

static void printf_raw_data_simple(navi_data_v3_raw_s raw_data)
{
  debug("name= %c%c\r\n"
        "lat = %d\r\n"
        "lon = %d\r\n"
        // "alt = %d\r\n"
        // "id  = %d\r\n"
        // "ttl = %d\r\n"
        // "typ = %d"
        ,
        raw_data.name[0], raw_data.name[1],
        raw_data.lat,
        raw_data.lon
        // raw_data.alt,
        // raw_data.nav.id,
        // raw_data.ttl,
        // raw_data.point_type
        );
}

void raw_to_processed(navi_data_v3_raw_s *incoming_friendly, navi_data_v3_s *processed_friendly)
{
  memcpy(processed_friendly->name, incoming_friendly->name, NAME_MAX);
  processed_friendly->cords.lat = (DEG_TO_RAD * incoming_friendly->lat) / DIGITS;
  processed_friendly->cords.lon = (DEG_TO_RAD * incoming_friendly->lon) / DIGITS;
  processed_friendly->cords.alt = incoming_friendly->alt;
  processed_friendly->nav = incoming_friendly->nav;
  processed_friendly->ttl = incoming_friendly->ttl;
  processed_friendly->point_type = incoming_friendly->point_type;
  processed_friendly->update = true;
}

ssize_t write_friendly(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
  navi_data_v3_raw_s incoming_friendly;
  navi_data_v3_s processed_friendly;
  debug("Received friendly length = %d", len);

  if (len != sizeof(navi_data_v3_raw_s)) {
    error("Incorrect length != %d", sizeof(navi_data_v3_raw_s));
    return len;
  }

  memcpy(&incoming_friendly, buf, len);
  printf_raw_data(incoming_friendly);
  raw_to_processed(&incoming_friendly, &processed_friendly);
  navigation_add_point_v2(&processed_friendly);

  return len;
}

static ssize_t write_friendlys(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
  navi_data_v3_raw_s incoming_friendly;
  navi_data_v3_s processed_friendly;
  uint8_t i = 0;
  debug("Received friendlys length = %d", len);

  if (len % sizeof(navi_data_v3_raw_s) != 0) {
    error("Incorrect length");
    return len;
  }

  i = len / sizeof(navi_data_v3_raw_s);

  for (i = 0; i < len / sizeof(navi_data_v3_raw_s); i++) {
    memcpy(&incoming_friendly, buf + (i * sizeof(navi_data_v3_raw_s)), sizeof(navi_data_v3_raw_s));
    raw_to_processed(&incoming_friendly, &processed_friendly);
    navigation_add_point_v2(&processed_friendly);
  }

  return len;
}

static ssize_t write_delete(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
  uint16_t id_delete;
  debug("Received delete length = %d", len);

  if (len != 2) {
    error("Incorrect frame != 2, length = %d", len);
  }

  memcpy(&id_delete, buf, len);

  if (id_delete & 0xF000) {
    warning("Weleting point has reserved flags %d", id_delete & 0xF000);
  }

  id_delete &= 0x0FFF;

  if (id_delete == 0) {
    error("ID 0 is not allowed");
    return len;
  }

  if (id_delete == 0xFFF) {
    navigation_del_all();
  } else {
    navigation_del_pos(id_delete);
  }

  return len;
}

static ssize_t write_myself(struct bt_conn *conn, const struct bt_gatt_attr *attr, const void *buf, uint16_t len, uint16_t offset, uint8_t flags)
{
  NAV_CORDS_RAW myself;
  debug("Received myself length = %d", len);

  if (len != sizeof(NAV_CORDS_RAW)) {
    error("Incorrect length == %d", len);
    return len;
  }

  memcpy(&myself, buf, len);

  LOGI("Myself lat=%d, lon=%d, alt=%d", myself.lat, myself.lon, myself.alt);
  navigation_update_myself(myself);

  return len;
}

void hasSecurityChangedTimer(struct k_timer *tmr)
{
  k_timer_stop(tmr);

  if (!curconn) return;

  bt_security_t sl = bt_conn_get_security(curconn);

  // If a CC2540 device, is should have changed the security level to 2 by now
  // If you force the notify subscription on a CC2540 right away it won't send data
  if (sl == BT_SECURITY_L1) {
    // uint8_t ccv = BT_GATT_CCC_NOTIFY;
    // bt_gatt_attr_write_ccc(curconn, &bt_srv.attrs[3], &ccv, 1, 0, 0);
    LOGI("Detected a CC2650 Chip (PARA Wireless)");
  } else
    LOGI("Detected a CC2540 Chip (non-PARA)");
}

K_TIMER_DEFINE(my_timer, hasSecurityChangedTimer, NULL);

static void connected(struct bt_conn *conn, uint8_t err)
{
  if (err) {
    LOGE("Bluetooth Connection failed %d", err);
  } else {
    LOGI("Bluetooth connected :)");
  }

  // Stop Advertising
  bt_le_adv_stop();

  curconn = bt_conn_ref(conn);

  struct bt_conn_info info;
  bt_conn_get_info(conn, &info);

  char addr_str[50];
  bt_addr_le_to_str(info.le.dst, addr_str, sizeof(addr_str));

  LOGI("Connected to Address %s", addr_str);

  bt_conn_info info2;
  bt_conn_get_info(conn, &info2);
  LOGI("PHY Connection Rx:%s TX:%s", printPhy(info2.le.phy->rx_phy),
       printPhy(info2.le.phy->tx_phy));

  // Set Connection Parameters - Request updated rate
  bt_conn_le_param_update(curconn, conparms);

  LOGI("Requesting coded PHY - %s",
       bt_conn_le_phy_update(curconn, &phy_params) ? "FAILED" : "Success");

  // Start a Timer, If we don't see a Security Change within this time
  // e.g. a CC2540 chip then force a subscription for the PARA chip
  k_timer_start(&my_timer, K_SECONDS(2), K_SECONDS(0));

  bleconnected = true;
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
  LOGW("Bluetooth disconnected (reason %d)", reason);

  // Start advertising
  int err = bt_le_adv_start(&my_param, ad, ARRAY_SIZE(ad), NULL, 0);
  if (err) {
    LOGE("Advertising failed to start (err %d)", err);
    return;
  }

  if (curconn) bt_conn_unref(curconn);

  curconn = NULL;
  bleconnected = false;
}

// Part of setTrainer to calculate CRC
// From OpenTX

void pushByte(uint8_t byte)
{
  crc ^= byte;
  if (byte == START_STOP || byte == BYTE_STUFF) {
    buffer[bufferIndex++] = BYTE_STUFF;
    byte ^= STUFF_MASK;
  }
  buffer[bufferIndex++] = byte;
}

/* Builds Trainer Data
 *     Returns the length of the encoded PPM + CRC
 *     Data saved into addr pointer
 */
int setTrainer(uint8_t *addr)
{
  // Allocate Channel Mappings, Set Default to all Center
  uint8_t *cur = buffer;
  bufferIndex = 0;
  crc = 0x00;

  buffer[bufferIndex++] = START_STOP;  // start byte
  pushByte(0x80);                      // trainer frame type?
  for (int channel = 0; channel < TrackerSettings::BT_CHANNELS; channel += 2, cur += 3) {
    uint16_t channelValue1 = chan_vals[channel];
    uint16_t channelValue2 = chan_vals[channel + 1];

    pushByte(channelValue1 & 0x00ff);
    pushByte(((channelValue1 & 0x0f00) >> 4) + ((channelValue2 & 0x00f0) >> 4));
    pushByte(((channelValue2 & 0x000f) << 4) + ((channelValue2 & 0x0f00) >> 8));
  }

  buffer[bufferIndex++] = crc;
  buffer[bufferIndex++] = START_STOP;  // end byte

  // Copy data to array
  memcpy(addr, buffer, bufferIndex);

  return bufferIndex;
}